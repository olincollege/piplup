import xml.etree.ElementTree as ET
import numpy as np
import os

# This script is a draft version of generating the multibody spring elements for a suction gripper (krishna)


def indent(elem, level=0):
    i = "\n" + level * "  "
    if len(elem):
        if not elem.text or not elem.text.strip():
            elem.text = i + "  "
        if not elem.tail or not elem.tail.strip():
            elem.tail = i
        for elem in elem:
            indent(elem, level + 1)
        if not elem.tail or not elem.tail.strip():
            elem.tail = i
    else:
        if level and (not elem.tail or not elem.tail.strip()):
            elem.tail = i


gripper_model_file = "../robotiq_description/sdf/robotiq_epick_2cup.sdf"

kCupOuterDiameter = 0.052
kCupMass = 0.02
kCupInertiaX = 0.000008
kCupInertiaY = 0.000008
kCupInertiaZ = 0.000007

kCupStiffness = 700
kCupDamping = 1.0
kCupMoveRange = 0.005
kCupHeight = 0.01

kNumEdgePtsPerCup = 4
kCupEdgePtDiameter = 0.002
kCupEdgeFriction = 0.6
kCupEdgeMoveRange = 0.005
kCupEdgeStiffness = 700 / 4
kCupEdgeDamping = 1.0 / 4
kCupEdgeHeight = 0.036
kNumCups = 2

tree = ET.parse(gripper_model_file)
root = tree.getroot()
root.set("xmlns:drake", "http://drake.mit.edu")
model = root.find(".//model")
model.append(ET.Comment("**BELOW AUTOGENERATED** by gen_suction_cup_spring_model.py"))
model.append(ET.Comment("modifying by hand not recommended."))
for cup_idx in range(kNumCups):
    cup_frame = f"suction_cup_{cup_idx}"
    cup_link_name = f"cup_{cup_idx}_link"

    cup_body_link = ET.SubElement(model, "link")
    cup_body_link.set("name", cup_link_name)
    pose = ET.SubElement(cup_body_link, "pose")
    pose.set("relative_to", cup_frame)
    pose.text = f"0 0 {-kCupHeight} 0 0 0"

    link_inertial = ET.SubElement(cup_body_link, "inertial")
    mass = ET.SubElement(link_inertial, "mass")
    mass.text = str(kCupMass / 2)
    action_point_link_inertia = ET.SubElement(link_inertial, "inertia")
    ixx = ET.SubElement(action_point_link_inertia, "ixx")
    ixx.text = str(kCupInertiaX / 2)
    ixy = ET.SubElement(action_point_link_inertia, "ixy")
    ixy.text = "0"
    ixz = ET.SubElement(action_point_link_inertia, "ixz")
    ixz.text = "0"
    iyy = ET.SubElement(action_point_link_inertia, "iyy")
    iyy.text = str(kCupInertiaY / 2)
    iyz = ET.SubElement(action_point_link_inertia, "iyz")
    iyz.text = "0"
    izz = ET.SubElement(action_point_link_inertia, "izz")
    izz.text = str(kCupInertiaZ / 2)

    base_to_cup_body_joint = ET.SubElement(model, "joint")
    base_to_cup_body_joint.set("name", f"base_to_cup_{cup_idx}_body_joint")
    base_to_cup_body_joint.set("type", "prismatic")
    ET.SubElement(base_to_cup_body_joint, "parent").text = cup_frame
    ET.SubElement(base_to_cup_body_joint, "child").text = cup_link_name
    axis = ET.SubElement(base_to_cup_body_joint, "axis")
    ET.SubElement(axis, "xyz").text = "0 0 1"
    limit = ET.SubElement(axis, "limit")
    ET.SubElement(limit, "effort").text = "0"
    ET.SubElement(limit, "lower").text = "0"
    ET.SubElement(limit, "upper").text = str(kCupMoveRange)
    dynamics = ET.SubElement(axis, "dynamics")
    ET.SubElement(dynamics, "spring_reference").text = "0"
    ET.SubElement(dynamics, "spring_stiffness").text = str(kCupStiffness)
    ET.SubElement(dynamics, "damping").text = str(kCupDamping)

    for edge_pt_idx in range(kNumEdgePtsPerCup):
        edge_pt_body_name = f"cup_{cup_idx}_edge_pt_{edge_pt_idx}_body"
        link = ET.SubElement(model, "link")
        link.set("name", edge_pt_body_name)
        pose = ET.SubElement(link, "pose")
        pose.set("relative_to", cup_frame)
        pose.text = "0 0 0 0 0 0"

        link_inertial = ET.SubElement(link, "inertial")
        mass = ET.SubElement(link_inertial, "mass")
        mass.text = str(kCupMass / 2 / kNumEdgePtsPerCup)
        action_point_link_inertia = ET.SubElement(link_inertial, "inertia")
        ixx = ET.SubElement(action_point_link_inertia, "ixx")
        ixx.text = str(kCupInertiaX / 2 / kNumEdgePtsPerCup)
        ixy = ET.SubElement(action_point_link_inertia, "ixy")
        ixy.text = "0"
        ixz = ET.SubElement(action_point_link_inertia, "ixz")
        ixz.text = "0"
        iyy = ET.SubElement(action_point_link_inertia, "iyy")
        iyy.text = str(kCupInertiaY / 2 / kNumEdgePtsPerCup)
        iyz = ET.SubElement(action_point_link_inertia, "iyz")
        iyz.text = "0"
        izz = ET.SubElement(action_point_link_inertia, "izz")
        izz.text = str(kCupInertiaZ / 2 / kNumEdgePtsPerCup)

        joint = ET.SubElement(model, "joint")
        joint.set("name", f"cup_{cup_idx}_body_to_edge_pt_{edge_pt_idx}_joint")
        joint.set("type", "prismatic")
        ET.SubElement(joint, "parent").text = cup_link_name
        ET.SubElement(joint, "child").text = edge_pt_body_name
        axis = ET.SubElement(joint, "axis")
        ET.SubElement(axis, "xyz").text = "0 0 1"
        limit = ET.SubElement(axis, "limit")
        ET.SubElement(limit, "effort").text = "0"
        ET.SubElement(limit, "lower").text = "0"
        ET.SubElement(limit, "upper").text = str(kCupEdgeMoveRange)
        dynamics = ET.SubElement(axis, "dynamics")
        ET.SubElement(dynamics, "spring_reference").text = "0"
        ET.SubElement(dynamics, "spring_stiffness").text = str(kCupEdgeStiffness)
        ET.SubElement(dynamics, "damping").text = str(kCupEdgeDamping)

        angle = 2 * np.pi / kNumEdgePtsPerCup * edge_pt_idx
        collision = ET.SubElement(link, "collision")
        collision.set("name", f"cup_{cup_idx}_edge_pt_{edge_pt_idx}_collision")
        ET.SubElement(
            collision, "pose"
        ).text = f"{(kCupOuterDiameter / 2) * np.cos(angle)} {(kCupOuterDiameter / 2) * np.sin(angle)} {-kCupEdgeHeight} 0 0 0"
        geometry = ET.SubElement(collision, "geometry")
        sphere = ET.SubElement(geometry, "sphere")
        ET.SubElement(sphere, "radius").text = str(kCupEdgePtDiameter / 2)

        prox_props = ET.SubElement(collision, "drake:proximity_properties")
        ET.SubElement(prox_props, "drake:mu_dynamic").text = str(kCupEdgeFriction)
        ET.SubElement(prox_props, "drake:mu_static").text = str(kCupEdgeFriction)

indent(root)

file_path_without_extension, _ = os.path.splitext(gripper_model_file)
tree = ET.ElementTree(root)
tree.write(
    f"{file_path_without_extension}_with_contact_springs.sdf",
    encoding="utf-8",
    xml_declaration=True,
)
